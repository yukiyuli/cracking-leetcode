# 代码随想录算法训练 Day 41 | 动态规划

Topic: Dynamic programming

Question: 343. 整数拆分, 96. 不同的二叉搜索树

Difficulty: Medium

- [x] Done

Completed: January 19, 2023

- [ ] Redo

## ****343. 整数拆分****

[leetcode](https://leetcode.cn/problems/integer-break/)

### ****动态规划：****

动规五部曲：

1. 确定dp数组以及下标的含义

dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。

1. 确定递推公式

得到dp[i]最大乘积可以从1遍历j，然后有两种渠道得到dp[i]。

一个是j * (i - j) 直接相乘。

一个是j * dp[i - j]，相当于是拆分(i - j)。

从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = Math.max(dp[i], Math.max((i - j) * j, dp[i - j] * j));

这里j不用拆分，j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。

在取最大值的时候，还要比较dp[i]呢，因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。

1. dp数组如何初始化

只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1。而dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。

1. 确定遍历顺序

递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j)); dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。

所以遍历顺序为：

```jsx
for (let i = 3; i <= n ; i++) {
    for (let j = 1; j <= i / 2; j++) {
        dp[i] = Math.max(dp[i], Math.max((i - j) * j, dp[i - j] * j));
    }
}
```

> 注意：
枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。
j的结束条件是 j < i - 1 ，其实 j < i 也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以 j < i - 1。
i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。
> 

这里拆分还可以优化，因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。

例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。

只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是最差也应该是拆成两个相同的 可能是最大值。

那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值

1. 举例推导dp数组

举例当n为10 的时候，dp数组里的数值，如下：

![Untitled](https://user-images.githubusercontent.com/101588752/213627074-8b2cc17b-3fee-459e-8789-73f962df1bc3.png)

JavaScript完整代码：

```jsx
/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function (n) {
    let dp = new Array(n + 1).fill(0);
    dp[2] = 1;
    for (let i = 3; i <= n; i++) {
        for (let j = 1; j <= i / 2; j++) {
            //j*(i-j)表示把i拆分为j和i-j两个数相乘
            //j*dp[i-j]表示把i拆分成j和继续把(i-j)这个数拆分，取(i-j)拆分结果中的最大乘积与j相乘
            dp[i] = Math.max(dp[i], Math.max((i - j) * j, dp[i - j] * j));
        }
    }
    return dp[n];
};
```

## ****96. 不同的二叉搜索树****

[leetcode](https://leetcode.cn/problems/unique-binary-search-trees/)

### 思路

先画图，看看有没有什么规律。

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。如图：

![Untitled 1](https://user-images.githubusercontent.com/101588752/213627098-e7e81353-b956-4d27-a077-983e30e41992.png)

来看看n为3的时候，有哪几种情况。

![Untitled 2](https://user-images.githubusercontent.com/101588752/213627107-13f88713-a43a-4b12-a650-4c48a8532180.png)

当1为头结点的时候，其右子树有两个节点，这两个节点的布局，和 n 为2的时候两棵树的布局是一样！

当3为头结点的时候，其左子树有两个节点，这两个节点的布局，也和n为2的时候两棵树的布局也是一样的！

当2为头结点的时候，其左右子树都只有一个节点，布局和n为1的时候只有一棵树的布局也是一样的！

> 注意：
我们是求不同树的数量，并不用把搜索树都列出来，所以虽然节点数值都不一样，但不用关心其具体数值的差异。
> 

发现到这里就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

所以可以总结为以下：

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：

![Untitled 3](https://user-images.githubusercontent.com/101588752/213627123-7cbec5f2-c79d-4a0c-8e5c-a29ec2e56baf.png)

动规五部曲：

1. 确定dp数组以及下标的含义

dp[i]： 1到i为节点组成的二叉搜索树的个数为dp[i]。

1. 确定递推公式

从上面的分析可以看出其递推关系：dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量。

1. dp数组如何初始化

只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

1. 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```jsx
for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

1. 举例推导dp数组

举例n为5时候的dp数组状态，如图：

![Untitled 4](https://user-images.githubusercontent.com/101588752/213627138-cfb29f33-9513-4e1f-99d1-d20f4c622533.png)

JavaScript完整代码：

```jsx
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
    let dp = new Array(n + 1).fill(0);
    dp[0] = 1;
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
};
```
